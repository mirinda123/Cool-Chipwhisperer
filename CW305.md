# 使用Chipwhisperer-Lite进行数据采集



## 连接图

<img src="https://205e55-1258657022.cos.ap-nanjing.myqcloud.com/chipwhisper/20221114155607.jpg" style="zoom: 25%;" />

粉色的波形采集线要连接到Chipwhisperer-Lite的MEASURE口而不是GLITCH口

## c与asm程序

## Jupyter脚本

设置SimpleSerial版本为1.1
设置设备为STM32F3

```
SCOPETYPE = 'OPENADC'
PLATFORM = 'CW308_STM32F3'
SS_VER = 'SS_VER_1_1'
```

编译：

```shell
%%bash -s "$PLATFORM" "$SS_VER"
cd 存放代码的文件夹
make PLATFORM=$1 CRYPTO_TARGET=NONE SS_VER=$2
```

编译后生成hex文件

检测板子的连接性：

```
%run "./Setup_Scripts/Setup_Generic.ipynb"
```

写入固件：

```python
cw.program_target(scope, prog, "xxx.hex".format(PLATFORM))
```

可选，对示波器进行配置：

```python
scope.adc.samples = 5000	# 采样点的数量
scope.adc.presamples = 300	# 预采样的数量
scope.adc.offset = 0	
# scope.adc.decimate = 4  # 可以调节下采样比例
```

```
%matplotlib notebook
import matplotlib.pylab as plt
```

分奇偶采集不同的曲线:

```python
import numpy as np
import random
from tqdm import tnrange
from tqdm.auto import tqdm
from numpy import savetxt
import galois
import gc

################下方这里是参数部分，可以修改#######
traces_per_part = 500  # 每一块文件多少条曲线
part = 200  # 分成多少块文件
part_start_index = 0  # 序号从多少号开始。如果是初始采集，就设置为0
filename_of_traces = "aes_capture"	# 曲线文件的文件名前缀
##############################################

global_counter = 0  # 全局的counter，用来判断这条曲线是奇数还是偶数
total_traces = part * traces_per_part  # 总共要采集的曲线数目
pbar = tqdm(total=total_traces)


# 此函数用于采集并保存一块文件
def mainProcess(num_of_traces):
    traces_array = []
    text_in_array = []
    text_out_array = []

    for i in tnrange(0, num_of_traces):

        reset_target(scope)  # 对板子复位
        global quanjucounter
        global pbar

        if quanjucounter % 2 == 0:  # # 如果是偶数曲线
            list_to_send = [1, 2, 3]  # 表示输入的数据
            msg = bytearray(list_to_send)
            scope.arm()
            target.simpleserial_write('g', msg)  # 这里的'g'命令要和c文件中的对应一致
            time.sleep(0.05)  # ❗这里必须要sleep,如果采集出错，尝试对睡眠时间进行调整

        
        else:	# 如果是奇数曲线
            list_to_send = [4, 5, 6]
            msg = bytearray(list_to_send)
            scope.arm()
            target.simpleserial_write('g', msg)
            time.sleep(0.05)	# ❗这里必须要sleep,如果采集出错，尝试对睡眠时间进行调整
        ret = scope.capture()
        if ret:
            print("Target timed out!")
        trace = scope.get_last_trace()  # 获得曲线
        recv_msg = target.simpleserial_read('r', 1)  # 这里的r命令要和c文件中对应一致

        traces_array.append(list(trace))
        text_in_array.append(list_to_send)
        text_out_array.append(list(recv_msg))
        quanjucounter += 1
        pbar.update(1)  # 更新进度条

    return np.array(traces_array), np.array(text_in_array), np.array(text_out_array)
for p in range(part):  # 遍历所有的part
    traces_arr, text_in_arr, text_out_arr = mainProcess(traces_per_part)
    np.save(filename_of_traces + "tracesPart{0}.npy".format(p + part_start_index), traces_arr)
    np.save(filename_of_traces + "textinPart{0}.npy".format(p + part_start_index), text_in_arr)
    np.save(filename_of_traces + "textoutPart{0}.npy".format(p + part_start_index), text_out_arr)
    counter += 1
    # del traces_array  # 回收
    # gc.collect()

pbar.close()

```



# 使用Pico示波器进行数据采集

## 连接图



## c与asm程序

## Python脚本

注意 



```
# todo:发现有时候会采集错误，就是一个曲线是一样的数值
# 并且好几条曲线都是一样的数值
# 应该写几行代码做个错误判断
# [[ 32512  32512  32512 ...  32512  32512  32512]
# [ 32512  32512  32512 ...  32512  32512  32512]
# [ 32512  32512  32512 ...  32512  32512  32512]]
# 一般发生在开始的几条曲线上
```

发送的数据不要超过simpleserial的上线！！！



.S 文件不要和.c文件同名，否则会被makefile删掉
.S名字没有严格规定
.S要大写
